/* eslint-disable @typescript-eslint/no-explicit-any */
import { PublicKey, SystemProgram, Transaction, Connection } from '@solana/web3.js';
import { BN, Program, AnchorProvider } from '@coral-xyz/anchor';

// SAFETY: 900 bytes fits safely within Solana's 1232-byte MTU limit per packet.
const CHUNK_SIZE = 900; 

export class ObsidianClient {
  constructor(
    public program: Program<any>, 
    public user: PublicKey
  ) {}
  get poolPda() {
    return PublicKey.findProgramAddressSync([Buffer.from('pool')], this.program.programId)[0];
  }

  get userLoanPda() {
    return PublicKey.findProgramAddressSync(
      [Buffer.from('loan'), this.user.toBuffer()],
      this.program.programId
    )[0];
  }

  get darkPoolPda() {
    return PublicKey.findProgramAddressSync([Buffer.from('dark_pool')], this.program.programId)[0];
  }

  getProofPda(orderId: BN) {
    return PublicKey.findProgramAddressSync(
      [Buffer.from('proof'), this.user.toBuffer(), orderId.toArrayLike(Buffer, 'le', 8)],
      this.program.programId
    )[0];
  }

  getOrderPda(orderId: BN) {
    return PublicKey.findProgramAddressSync(
      [Buffer.from('order'), this.user.toBuffer(), orderId.toArrayLike(Buffer, 'le', 8)],
      this.program.programId
    )[0];
  }
  async mockEncrypt(data: Uint8Array): Promise<Buffer> {
    const ownerBytes = this.user.toBuffer();
    const result = new Uint8Array(ownerBytes.length + data.length);
    // Prefix data with owner public key to simulate "sealing" the data
    result.set(ownerBytes);
    result.set(data, ownerBytes.length);
    return Buffer.from(result);
  }
  /**
   * * @param proof - The ZK Proof bytes generated by Noir
   * @param orderId - Unique identifier for the order/proof
   * @param isOrderProof - True for Dark Pool, False for Compliance/KYC
   */
  async uploadProof(proof: Uint8Array, orderId: BN, isOrderProof: boolean = true) {
    if (proof.length === 0) throw new Error("Cannot upload empty proof.");

    const proofPda = this.getProofPda(orderId);
    const provider = this.program.provider as AnchorProvider;
    const connection = provider.connection;
    const transactions: Transaction[] = [];
    console.log(`[Obsidian] Preparing Smart Upload bundle for ${proof.length} bytes...`);
    const accountInfo = await connection.getAccountInfo(proofPda);
    if (!accountInfo) {
        console.log("[Obsidian] Queueing Init Transaction...");
        const initTx = await this.program.methods
            .createProofAccount(orderId)
            .accounts({
                proofAccount: proofPda,
                user: this.user,
                systemProgram: SystemProgram.programId,
            })
            .transaction();
        transactions.push(initTx);
    }
    let offset = 0;
    while (offset < proof.length) {
        const end = Math.min(offset + CHUNK_SIZE, proof.length);
        const chunk = proof.slice(offset, end);
        
        const chunkTx = await this.program.methods
            .storeOrderProof(Buffer.from(chunk), isOrderProof)
            .accounts({
                proofAccount: proofPda,
                owner: this.user,
            })
            .transaction();
        
        transactions.push(chunkTx);
        offset += CHUNK_SIZE;
    }

    console.log(`[Obsidian] Requesting signature for ${transactions.length} txs...`);
    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');
    
    transactions.forEach(tx => {
        tx.recentBlockhash = blockhash;
        tx.feePayer = this.user;
    });

    // SIGN ALL AT ONCE
    let signedTransactions;
    try {
        signedTransactions = await provider.wallet.signAllTransactions(transactions);
    } catch (err) {
        throw new Error("User rejected the transaction bundle.");
    }

    console.log("[Obsidian] Broadcasting...");
    
    for (const [index, tx] of signedTransactions.entries()) {
        const signature = await connection.sendRawTransaction(tx.serialize(), {
            skipPreflight: true, // Reliable for heavily bundled txs
            maxRetries: 3
        });
        const isLast = index === signedTransactions.length - 1;
        const isInit = index === 0 && !accountInfo;

        if (isLast || isInit) {
            console.log(`[Obsidian] Confirming Part ${index + 1}/${signedTransactions.length}...`);
            await connection.confirmTransaction({
                signature,
                blockhash,
                lastValidBlockHeight
            }, 'confirmed');
        } else {
            console.log(`[Obsidian] Sent Part ${index + 1}/${signedTransactions.length}`);
        }
    }

    console.log("[Obsidian] Upload Complete.");
  }
  async settleBatch(batchId: BN, settlementPrice: number) {
    console.log(`[Node] Settling Batch ${batchId.toString()} at price $${settlementPrice}...`);
    const priceNative = new BN(Math.floor(settlementPrice * 100));
    const tx = await this.program.methods
      .batchMatchOrders(batchId, priceNative)
      .accounts({
        orderBook: this.darkPoolPda,
        authority: this.user, 
      })
      .transaction();

    const provider = this.program.provider as AnchorProvider;
    const connection = provider.connection;
    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');
    tx.recentBlockhash = blockhash;
    tx.feePayer = this.user;
    const signedTx = await provider.wallet.signTransaction(tx);

    const signature = await connection.sendRawTransaction(signedTx.serialize(), {
      skipPreflight: true, 
    });
    await connection.confirmTransaction({
      signature,
      blockhash,
      lastValidBlockHeight
    }, 'confirmed');
    console.log(`[Node] Batch Settled! Sig: ${signature}`);
    return signature;
  }

  async submitBid(auctionId: BN, amount: number) {
    console.log(`[Auction] Submitting bid for Auction #${auctionId.toString()}...`);
    const bidData = new TextEncoder().encode(JSON.stringify({ amount, timestamp: Date.now() }));
    const encryptedBid = await this.mockEncrypt(bidData);
    const bidProof = Buffer.alloc(64).fill(1);
    const bidPda = PublicKey.findProgramAddressSync(
      [
        Buffer.from('bid'), 
        auctionId.toArrayLike(Buffer, 'le', 8),
        this.user.toBuffer()
      ],
      this.program.programId
    )[0];

    const auctionPda = PublicKey.findProgramAddressSync(
      [
        Buffer.from('auction'), 
        auctionId.toArrayLike(Buffer, 'le', 8)
      ],
      this.program.programId
    )[0];
    const tx = await this.program.methods
      .submitEncryptedBid(auctionId, Buffer.from(encryptedBid), bidProof)
      .accounts({
        auction: auctionPda,
        bid: bidPda,       
        bidder: this.user,
        systemProgram: SystemProgram.programId,
      })
      .transaction();
    const provider = this.program.provider as AnchorProvider;
    const { blockhash, lastValidBlockHeight } = await provider.connection.getLatestBlockhash('confirmed');
    
    tx.recentBlockhash = blockhash;
    tx.feePayer = this.user;

    const signedTx = await provider.wallet.signTransaction(tx);
    const signature = await provider.connection.sendRawTransaction(signedTx.serialize(), {
        skipPreflight: true,
    });

    await provider.connection.confirmTransaction({
        signature,
        blockhash,
        lastValidBlockHeight
    }, 'confirmed');

    console.log(`[Auction] Bid Successfully Placed! Sig: ${signature}`);
    return signature;
  }

  async initializeAuction(auctionId: BN, userLoan: PublicKey) {
    console.log(`[Admin] Initializing Auction #${auctionId.toString()}...`);
    const [auctionPda, bump] = PublicKey.findProgramAddressSync(
      [Buffer.from('auction'), auctionId.toArrayLike(Buffer, 'le', 8)],
      this.program.programId
    );
    console.log("Derived Auction Address:", auctionPda.toBase58());
    console.log("Derived Bump:", bump);
    const collateralAmount = new BN(5 * 1e9); 
    const minBid = new BN(1 * 1e9);           
    const duration = new BN(300);             

    const tx = await this.program.methods
      .startLiquidationAuction(
        auctionId, 
        collateralAmount, 
        minBid, 
        duration, 
        bump 
      )
      .accounts({
        auction: auctionPda,
        userLoan: userLoan,
        authority: this.user,
        systemProgram: SystemProgram.programId,
      })
      .transaction();
    const provider = this.program.provider as AnchorProvider;
    const { blockhash, lastValidBlockHeight } = await provider.connection.getLatestBlockhash('confirmed');
    
    tx.recentBlockhash = blockhash;
    tx.feePayer = this.user;

    const signedTx = await provider.wallet.signTransaction(tx);
    const signature = await provider.connection.sendRawTransaction(signedTx.serialize(), {
        skipPreflight: true,
    });

    await provider.connection.confirmTransaction({ 
        signature, 
        blockhash, 
        lastValidBlockHeight 
    }, 'confirmed');

    console.log(`[Admin] Auction Initialized! Sig: ${signature}`);
  }
}